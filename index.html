<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Кубок Победителя</title>
    <style>
        :root {
            --bg: radial-gradient(circle at 20% 20%, #1b2340 0%, #0d1226 35%, #070912 100%);
            --panel: rgba(19, 24, 43, 0.6);
            --text: #e8ecf2;
            --accent: #f7d046;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            min-height: 100vh;
            background: var(--bg);
            color: var(--text);
            font-family: "Poppins", "Segoe UI", system-ui, -apple-system, sans-serif;
            overflow: hidden;
        }
        .layout {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #scene {
            position: absolute;
            inset: 0;
        }
        canvas { display: block; width: 100%; height: 100%; }
        .overlay {
            position: absolute;
            top: 24px;
            left: 24px;
            padding: 18px 20px;
            border-radius: 14px;
            background: var(--panel);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.07);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
            max-width: 320px;
        }
        .overlay h1 {
            margin: 0 0 8px;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        .overlay p {
            margin: 4px 0;
            font-size: 14px;
            color: #c7d0dd;
            line-height: 1.4;
        }
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-top: 10px;
            border-radius: 10px;
            background: rgba(247, 208, 70, 0.12);
            color: var(--accent);
            font-weight: 600;
            font-size: 13px;
            letter-spacing: 0.3px;
        }
        .hud {
            position: absolute;
            bottom: 22px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            border-radius: 12px;
            background: rgba(12, 15, 28, 0.75);
            color: #dbe4f5;
            font-size: 13px;
            letter-spacing: 0.3px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }
        .key {
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="layout">
        <div id="scene"></div>
        <div class="overlay">
            <h1>3D Кубок победителя</h1>
            <p>Базовая сцена для демонстрации кубка. Можно вращать, приближать и рассматривать со всех сторон.</p>
            <div class="badge">Three.js · Орбитальное управление</div>
        </div>
        <div class="hud">
            <span class="key">ЛКМ</span> вращать
            <span class="key">ПКМ/Shift+ЛКМ</span> панорама
            <span class="key">Колесо</span> зум
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

        const container = document.getElementById("scene");

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x05070e, 1);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 3.6);
        camera.lookAt(0, 0.5, 0);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minDistance = 1.6;
        controls.maxDistance = 6;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.5, 0);
        controls.update();

        const ambient = new THREE.AmbientLight(0xf0f4ff, 0.25);
        scene.add(ambient);

        const hemi = new THREE.HemisphereLight(0xf6f7fb, 0x121420, 0.9);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.15);
        dir.position.set(4, 6, 3);
        dir.castShadow = true;
        dir.shadow.mapSize.set(2048, 2048);
        dir.shadow.camera.near = 1;
        dir.shadow.camera.far = 15;
        scene.add(dir);

        const rim = new THREE.PointLight(0xffd27f, 0.9, 12);
        rim.position.set(-3, 2.8, 2.5);
        scene.add(rim);

        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(10, 96),
            new THREE.MeshPhysicalMaterial({
                color: 0x101528,
                metalness: 0.18,
                roughness: 0.55,
                clearcoat: 0.25,
                clearcoatRoughness: 0.5,
                transparent: true,
                opacity: 0.95
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.12;
        ground.receiveShadow = true;
        scene.add(ground);

        function createTrophy() {
            const metal = new THREE.MeshPhysicalMaterial({
                color: 0xf7d046,
                metalness: 1,
                roughness: 0.18,
                clearcoat: 0.6,
                clearcoatRoughness: 0.1,
                reflectivity: 1
            });

            const profile = [
                new THREE.Vector2(0, 0.05),
                new THREE.Vector2(0.5, 0),
                new THREE.Vector2(0.55, 0.05),
                new THREE.Vector2(0.6, 0.2),
                new THREE.Vector2(0.62, 0.45),
                new THREE.Vector2(0.5, 0.55),
                new THREE.Vector2(0.35, 0.58),
                new THREE.Vector2(0.25, 0.62),
                new THREE.Vector2(0.2, 0.7),
                new THREE.Vector2(0.18, 0.95),
                new THREE.Vector2(0.1, 1.05),
                new THREE.Vector2(0.05, 1.15)
            ];

            const cup = new THREE.Mesh(new THREE.LatheGeometry(profile, 96), metal);
            cup.castShadow = true;
            cup.receiveShadow = true;

            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 0.6, 48), metal);
            stem.position.y = -0.45;
            stem.castShadow = true;
            stem.receiveShadow = true;

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.45, 0.28, 48), metal);
            base.position.y = -0.9;
            base.castShadow = true;
            base.receiveShadow = true;

            const plinth = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.52, 0.18, 48),
                new THREE.MeshStandardMaterial({ color: 0x1f2430, metalness: 0.35, roughness: 0.7 })
            );
            plinth.position.y = -1.12;
            plinth.castShadow = true;
            plinth.receiveShadow = true;

            const handleGeom = new THREE.TorusGeometry(0.38, 0.04, 24, 72, Math.PI * 0.8);
            const handleL = new THREE.Mesh(handleGeom, metal);
            handleL.rotation.z = Math.PI / 2;
            handleL.position.set(-0.35, 0.65, 0);
            handleL.castShadow = true;

            const handleR = handleL.clone();
            handleR.position.x *= -1;

            const testGem = new THREE.Mesh(
                new THREE.IcosahedronGeometry(0.22, 1),
                new THREE.MeshStandardMaterial({ color: 0x8fd3ff, metalness: 0.1, roughness: 0.2, emissive: 0x0a2a4f, emissiveIntensity: 0.6 })
            );
            testGem.position.set(0.95, 0.5, 0);
            testGem.castShadow = true;

            const group = new THREE.Group();
            group.add(cup, stem, base, plinth, handleL, handleR, testGem);
            group.position.y = 0.4;

            return group;
        }

        const trophy = createTrophy();
        scene.add(trophy);

        // Дополнительный тестовый объект (куб) для проверки видимости
        const testCube = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.35, 0.35),
            new THREE.MeshStandardMaterial({ color: 0xff6f61, metalness: 0.2, roughness: 0.4, emissive: 0x300a0a, emissiveIntensity: 0.4 })
        );
        testCube.position.set(-0.9, 0.4, 0);
        testCube.castShadow = true;
        testCube.receiveShadow = true;
        scene.add(testCube);

        // Загрузка внешней модели кубка (GLB)
        const loader = new GLTFLoader();
        loader.load(
            "./glass_trophy.glb",
            (gltf) => {
                const model = gltf.scene;
                // Авто-нормализация размера
                const box = new THREE.Box3().setFromObject(model);
                const size = new THREE.Vector3();
                box.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z) || 1;
                const scale = 1.6 / maxDim;
                model.scale.setScalar(scale);

                // Центровка по основанию
                const center = new THREE.Vector3();
                box.getCenter(center);
                model.position.sub(center.multiplyScalar(scale));
                model.position.y += (size.y * scale) / 2 + 0.05; // приподнять чуть над полом

                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // усилить блеск, если PBR материалы
                        if (child.material && child.material.roughness !== undefined) {
                            child.material.roughness = Math.max(0.05, child.material.roughness * 0.6);
                            child.material.metalness = Math.min(1, (child.material.metalness || 0.5) + 0.2);
                        }
                    }
                });

                model.name = "GLB_Trophy";
                scene.add(model);
                trophy.visible = false; // скрываем процедурный, если GLB загрузился
            },
            undefined,
            (err) => {
                console.warn("GLB load error", err);
            }
        );

        let lastTime = performance.now();
        const idleSpeed = 0.25; // rad/sec

        function resize() {
            const { innerWidth: w, innerHeight: h } = window;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            trophy.rotation.y += idleSpeed * delta;
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener("resize", resize);
        resize();
        animate();
    </script>
</body>
</html>
